const waitForResponse = (page, ship) => {
  return new Promise((resolve) => {
    page.on("response", async function callback(response) {
      if (response.url().includes("/vesselDetails/voyageInfo/shipid")) {
        const u = response.url();
        if (ship.search === u) {
          try {
            ship.data = await response.json();
            shipsStack.splice(shipsStack.indexOf(ship.id), 1);
            resolve(response);
            page.removeListener("response", callback);
            const status = shipsStack.length === 0 ? true : false;

            if (status) {
              page.off("response", getVesselJSONList);
              await browser.close();
              endScrapping();
            }
          } catch (error) {
            shipsStack.splice(shipsStack.indexOf(ship.id), 1);
            ship.data = {
              data: { departurePort: { name: "error", timestamp: 0 } },
            };
            resolve(response);
            page.removeListener("response", callback);
            const status = shipsStack.length === 0 ? true : false;

            if (status) {
              page.off("response", getVesselJSONList);
              await browser.close();
              endScrapping();
            }
          }
        }
      }
    });
  });
};

async function getPageScreenshot(url) {
  const browser = await puppeteer.launch({ headless: false });
  const page = await browser.newPage();
  await page.goto(url);
  //   await page.setViewport({ width: 10, height: 10 });
  await page.screenshot({ path: "pageshot.png" });
  await browser.close();
}

  // const response = await page.waitForResponse((response) => {
  //   if (
  //     response.url().includes("/global_search/search?term=") &&
  //     response.request().method() === "GET"
  //   ) {
  //     let responseJson = await response.json();
  //     console.log(responseJson);
  //   }
  //   //  ;
  // });

    const ships = [];
  for (const ship of ships) {
    if (response.url() === ship) {
      console.log(ship);

      var date = new Date(1611631440);
      ships.splice(ships.indexOf(ship), 1);
    }
  }

      if (responseJson.results.length) {
      for (const ship of responseJson.results) {
        const path = "https://www.marinetraffic.com" + ship.url;
        ships.push(
          `https://www.marinetraffic.com/vesselDetails/voyageInfo/shipid:${ship.id}`
        );
        // await page.goto(path, { waitUntil: "load" });
      }
      // ("https://www.marinetraffic.com/vesselDetails/voyageInfo/shipid:372738");
      // ("https://www.marinetraffic.com/en/vesselDetails/vesselInfo/shipid:372738");
      // (https://www.marinetraffic.com/en/vesselDetails/vesselInfo/shipid:372738);
    }

      // let result = await page.evaluate(() => {
  //   const input = document.getElementById("searchMT");
  //   input.value = "DRAWSKO";
  //   console.log(input);
  //   // обычный код в среде страницы
  //   return {};
  // });

  // await page.("header");

  class BrowserHandler {
  constructor() {
    const launch_browser = async () => {
      this.browser = false;
      this.browser = await puppeteer.launch();
      this.browser.on('disconnected', launch_browser);
    };
    
    (async () => {
      await launch_browser();
    })();
  }
}

  // const max = count * 50;
  // let response;
  // if (max > 50) {
  //   response = await prompts({
  //     type: "multiselect",
  //     name: "boolean",
  //     message: `Больше чем ${max} позиций найдено, продожить? (yes/no)`,
  //     choices: [
  //       { title: "Да", value: true },
  //       { title: "Нет", value: false },
  //     ],
  //   });
  // }
  // if (response) {
  //   return;
  // }
  const getSearchJSON = async (response) => {
  if (
    response.url().includes("/searchjson?what=&term=") &&
    response.request().method() === "GET"
  ) {
    let responseJson = await response.json();
    page.off("response", getSearchJSON);
    page.on("response", getVesselJSONList);
    if (responseJson.length) {
      for (const ship of responseJson.results) {
        const id = ship.shipid;
        const url = `${homeURL}/en/ais/details/ships/shipid:${id}`;
        const search = `${homeURL}/vesselDetails/voyageInfo/shipid:${id}`;
        ships.push({ url, search, id, visited: false });
        await page.goto(url, { waitUntil: "load" });
      }
    }
  }
};
Node.js:

var fs = require('fs');
fs.writeFile("test.txt", jsonData, function(err) {
    if (err) {
        console.log(err);
    }
});
Browser (webapi):

function download(content, fileName, contentType) {
    var a = document.createElement("a");
    var file = new Blob([content], {type: contentType});
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
}
download(jsonData, 'json.txt', 'text/plain');
      // console.log(response);
      // ship.voyageInfo = responses[0];
      // ship.vesselInfo = responses[1];
      // ship.latestPosition = responses[2];

      // page.goto(ship.url, { waitUntil: "load" });
      // ship.voyageInfo = await page
      //   .waitForResponse((response) =>
      //     response.url().includes("/vesselDetails/voyageInfo/shipid:")
      //   )
      //   .then((response) => response.json())
      //   .catch((err) => {});
      // ship.vesselInfo = await page
      //   .waitForResponse((response) =>
      //     response.url().includes("/vesselDetails/vesselInfo/shipid:")
      //   )
      //   .then((response) => response.json())
      //   .catch((err) => {});
      // ship.latestPosition = await page
      //   .waitForResponse((response) =>
      //     response.url().includes("/vesselDetails/latestPosition/shipid:")
      //   )
      //   .then((response) => response.json())
      //   .catch((err) => {});

  // await page.click("header");
  // await page.focus("#searchMT");
  // await page.keyboard.type("HHH"); //DRAWSKO

  const getVesselJSONList = async (response) => {
  if (
    response.url().includes("/vesselDetails/voyageInfo/shipid") &&
    response.request().method() === "GET"
  ) {
    for (const ship of ships) {
      if (ship.search === response.url()) {
        try {
          ship.data = await response.json();
          shipsStack.splice(shipsStack.indexOf(ship.id), 1);
        } catch (error) {
          shipsStack.splice(shipsStack.indexOf(ship.id), 1);
          ship.data = {
            data: { departurePort: { name: "error", timestamp: 0 } },
          };
        }
      }
    }
    const status = shipsStack.length === 0 ? true : false;

    if (status) {
      page.off("response", getVesselJSONList);
      await browser.close();
      endScrapping();
    }
  }
};